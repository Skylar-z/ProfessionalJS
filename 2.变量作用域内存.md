1.基本类型和引用类型
1.1 只有引用类型可以添加属性，基本类型不可以，添加了不会报错，但是会undefined。
1.2 复制变量  看复制的是基本类型还是引用类型，基本类型复制值，引用类型复制指针
1.3 传参
* 这里有个天坑，就是很多人都以为对象作为参数传进来，进行的也是引用传递。但其实不是，参数只能按值传递，只是参数可以修改里面的值。但当在函数里面将参数赋值给另一个对象，外面的变量是没有跟着一起改变的。
```js
function test(person) {
person.age = 26
person = {
    name: 'yyy',
    age: 30
}
return person
}
const p1 = {
name: 'yck',
age: 25
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) 
```
1.4 检测  基本数据类型用typeof，引用类型用instanceof


2.执行环境及作用域
  执行环境是js中最重要的一个概念。
  执行环境定义了变量or函数有权访问的其他数据。每个执行环境都有一个变量对象vo，环境中定义的变量和函数都保存在vo中。标识符解析会沿着作用域链一级一级往上搜索，直到找到标识符，找不到就会报错。
  全局执行环境是最外围的一个执行环境，不同宿主对象不同，在web浏览器中全局执行环境就是window。
  某个执行环境中所有代码执行完毕后，该环境会被销毁。全局环境在关闭网页或浏览器时才被销毁。
    2.1 没有块级作用域：特别是在if语句和for语句里，变量存在于全局，而不是语句里。所以语句外可以访问到语句内的变量，导致经典的for语句问题。
```js
for (var i = 1; i <= 5; i++) {
 dosomething();
}
console.log(i)  
```
var声明的变量会自动被添加到最接近的环境中，而不使用var申明的变量添加到全局中。
    变量的搜索是由局部往外的。
    2.2 垃圾回收机制：离开作用域（闭包除外）的变量会自动标记为可回收，在垃圾回收期间被删除。
    垃圾收集算法分为标记清除和引用计数
    引用计数无法清除循环引用的变量。变量不需要时手动释放引用。